<!DOCTYPE html>
<html lang="en">
	<head>
		<title>sol survivor nft</title>
		<meta charset="utf-8">
		<meta name="viewport" content="user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			a {
				color: #f00;
			}
			body{
				width:100vw;
				height:95vh;
				overflow:hidden;
				background-image:url('./.gif');
				background-repeat:no-repeat;
				background-size:contain;
				background-position: center;
			}
			.ac {  /* prevent dat-gui from being selected */
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			#container{
				background-size: auto;
				background-position: bottom;
			}
			.no-pointer-events {
				pointer-events: none;
			}
			#recordButton{
				background:red;
				color:black;
				position:absolute;
				bottom:0vh;
				left:1vw;
			}
			.control-disabled {
				color: #888;
				text-decoration: line-through;
			}
		</style>
		<script src='https://mrdoob.github.io/stats.js/build/stats.min.js'></script>	
	</head>
	<body>
		<div id="container" style="overflow:hidden;height:100vh"></div>
		<script type="module">
			function runningLocal(){
				if(location.host.search("localhost") < 0){
					return false;
				}
				return true;
			}
			if(!runningLocal()){
				console.log = function(){}
				console.warn = function(){}
			}
			import * as THREE from './three.js';
			import { GUI } from './dat.gui.module.js';
			import { GLTFLoader } from './GLTFLoader.js';
			import { OrbitControls } from './OrbitControls.js';
			import * as Util from './util.js';

			let Record2 = Util.default.Record2;
			let scene, renderer, camera;
			let model, skeleton, mixer,clock;
			let idle;
			let controls;
			init();
			function init() {

				const container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );

				camera.position.set( -299.7774832758518, -10.445960103414468, 95.89058434317982 );

				camera.lookAt( 0, 1, 0 );
				clock = new THREE.Clock();
				scene = new THREE.Scene();	
				
				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
				hemiLight.position.set( 0, 20, 0 );
				scene.add( hemiLight );

				const dirLight = new THREE.DirectionalLight( 0xffffff );
				dirLight.position.set( - 3, 10, - 10 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.top = 2;
				dirLight.shadow.camera.bottom = - 2;
				dirLight.shadow.camera.left = - 2;
				dirLight.shadow.camera.right = 2;
				dirLight.shadow.camera.near = 0.1;
				dirLight.shadow.camera.far = 40;
				scene.add( dirLight );


				const mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 1, 1 ), new THREE.MeshPhongMaterial( { color: "black", depthWrite: false } ) );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				const loader = new GLTFLoader();

				//~ loader.load( 'models/soldier.gltf', function ( gltf ) {
					//~ let model = gltf.scene;				
					//~ scene.add( model );
					//~ model.traverse( function ( object ) {
						//~ if ( object.isMesh ) object.castShadow = true;
					//~ });
					//~ //
					//~ skeleton = new THREE.SkeletonHelper( model );
					//~ skeleton.visible = false;
					//~ scene.add( skeleton );
					//~ const animations = gltf.animations;
					//~ console.log(animations);
					//~ mixer = new THREE.AnimationMixer( model );
					//~ idle = mixer.clipAction(animations[6] );
					//~ idle.play();
					//~ animate();
				//~ });
				//~ loader.load( 'models/nakedv3.glb', function ( gltf ) {
					//~ let model = gltf.scene;
					//~ let scaleUp = 65;
					//~ model.scale.x *= scaleUp;
					//~ model.scale.y *= scaleUp;
					//~ model.scale.z *= scaleUp;
					//~ model.position.y -= 90;					
					//~ let body = model.children[0].children[1].children[0];
					//~ body.material.opacity = 0.5;
					//~ body.material.transparent = true;
					//~ scene.add( model );
					//~ model.traverse( function ( object ) {
						//~ //if ( object.isMesh ) object.castShadow = true;
					//~ });
					//~ //
					//~ const animations = gltf.animations;
					//~ mixer = new THREE.AnimationMixer( model );
					//~ idle = mixer.clipAction(animations[0] );
					//~ idle.play();
					//~ animate();
				//~ });
				//~ loader.load( 'models/knight.glb', function ( gltf ) {
					//~ let model = gltf.scene;				
					//~ scene.add( model );
					//~ model.traverse( function ( object ) {
						//~ if ( object.isMesh ) object.castShadow = true;
					//~ });
					//~ //
					//~ skeleton = new THREE.SkeletonHelper( model );
					//~ skeleton.visible = false;
					//~ scene.add( skeleton );
					//~ const animations = gltf.animations;
					//~ mixer = new THREE.AnimationMixer( model );
					//~ idle = mixer.clipAction(animations[8] );
					//~ idle.play();
					//~ animate();
				//~ });	
				//displaybox
				//~ loader.load( 'models/olga_nft.glb', function ( gltf ) {
					//~ let model = gltf.scene;
					//~ let box = model.children[0].children[1];
					//~ box.visible = false;
					//~ let scaleUp = 67;
					//~ model.scale.x *= scaleUp;
					//~ model.scale.y *= scaleUp;
					//~ model.scale.z *= scaleUp;
					//~ model.position.y -= 130;	
					//~ scene.add( model );
					//~ model.traverse( function ( object ) {
						//~ if ( object.isMesh ) object.castShadow = true;
					//~ });
					//~ //
					//~ mixer = new THREE.AnimationMixer( model );
					//~ const animations = gltf.animations;
					//~ mixer = new THREE.AnimationMixer( model );
					//~ idle = mixer.clipAction(animations[0] );
					//~ idle.clampWhenFinished = true
					//~ idle.repetitions = 6;
					//~ idle.timeScale *= 6/10;
					//~ animate();
					//~ idle.play();
				//~ });				

				//~ loader.load( 'models/jaybeezy_v7.glb', function ( gltf ) {
					//~ let model = gltf.scene;
					//~ let scaleUp = 95;
					//~ let box = model.children[0];
					//~ while (box.children.length === 1){
						//~ box = box.children[0];
					//~ }
					//~ box = box.children[1];
					//~ box.visible = false;					
					//~ model.scale.x *= scaleUp;
					//~ model.scale.y *= scaleUp;
					//~ model.scale.z *= scaleUp;
					//~ model.position.y -= 150;
					//~ model.position.x -= 30;				
					//~ scene.add( model );
					//~ model.traverse( function ( object ) {
						//~ if ( object.isMesh ) object.castShadow = true;
					//~ });
					//~ //
					//~ mixer = new THREE.AnimationMixer( model );
					//~ const animations = gltf.animations;
					//~ mixer = new THREE.AnimationMixer( model );
					//~ let standUp = mixer.clipAction(animations[0] );
					//~ standUp.play();
					//~ animate();
				//~ });
				
				loader.load( 'models/poh.glb', function ( gltf ) {
					let model = gltf.scene;
					let scaleUp = 65;
					model.scale.x *= scaleUp;
					model.scale.y *= scaleUp;
					model.scale.z *= scaleUp;
					model.position.y -= 95;
					model.position.z += 0;					
					scene.add( model );
					const animations = gltf.animations;
					mixer = new THREE.AnimationMixer( model );
					let reverseKick = mixer.clipAction(animations[0] );
					reverseKick.timeScale /= 1.2
					reverseKick.play();
					animate();
				});				
				
				renderer = new THREE.WebGLRenderer( { antialias: true,alpha:true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );
				//camera touch controls
				if( window.location.search === "?controls=true" ){controls = new OrbitControls( camera, renderer.domElement );}
			}
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			let count = 0;
			let normalRate = 1000/30;
			var stats = new Stats();
			stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: custom
			document.body.appendChild( stats.dom );
			function animate() {
				if(runningLocal()){stats.begin();}
				let mixerUpdateDelta = clock.getDelta();
				mixer.update( mixerUpdateDelta );
				renderer.render( scene, camera );
				Record2();
				if(!controls){
					//rotate
					let target = scene;
					let radius = 400;
					let constant = -2;
					count++;;
					camera.position.x = target.position.x + radius * Math.cos( constant * count/100 );         
					camera.position.z = target.position.z + radius * Math.sin( constant * count/100 );
					camera.lookAt( target.position );
				}
				if(runningLocal()){stats.end();}
				setTimeout(()=>{
					requestAnimationFrame( animate );
				},normalRate);
			}
		</script>
	</body>
</html>
